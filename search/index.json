[{"content":"最大公约数和最小公倍数 最大公约数和最小公倍数定义\n最大公约数定义: 最大公约数:指两个或多个整数共有约数中最大的一个。\n最小公倍数定义: 两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。\n求最大公约数 辗转相除法（欧几里得算法）求 1 2 3 4 int gcd(int a, int b) { return a % b == 0 ? b : gcd(b, a%b); } 1 2 3 4 5 6 7 8 9 10 11 int gcd(int x,int y) { int z=y; while(x%y!=0) { z=x%y; x=y; y=z; } return z; } 更相减损法 用较大数减去较小数,再不断用差减减数得到新的差(当差是负数时,就反过来减),不停循环直到减数和差相等为止,此时这个相等的数就是最大公约数。\n为什么不断大数减小数，最后两个数相等时，那个数就是最大公约数?\n这个算法的核心基于一个非常重要的数学定理：\n如果 a 和 b都是正整数，且 a\u0026gt;=b那么 gcd⁡(a,b)=gcd⁡(a−b,b)。\n因为 d能整除 a和 b，根据整除的性质，d也一定能整除它们的差 a−b 为什么最后相等时的数就是最大公约数？\n换句话说：我们通过不断相减，把两个较大的数逐渐变小，但始终保持它们的最大公约数不变，直到两个数变得显而易见（相等），这时它们的值就是我们要找的最大公约数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int gcd(int a,int b) { while(a!=b) { if(a\u0026gt;b) { a=a-b; } else { b=b-a; } } return a; } 类比辗转相除法来说\n你可能听说过用除法求最大公约数的方法（辗转相除法）：\n用 a除以 b得到余数 r 那么 gcd⁡(a,b)=gcd⁡(b,r) 这其实是更相减损术的“加速版”——减法要减很多次才能达到的效果，除法一步就完成了。比如 24−15=9相当于做了一次减法，而 24÷15余 9直接得到同样的效果。\n好的！我们通过具体例子来对比更相减损术（减法）和辗转相除法（除法），你就能明白为什么说除法是减法的“加速版”。\n例子一：求 gcd(56, 98)\n更相减损术（减法）\n98−56=42 → (56, 42) 56−42=14 → (42, 14) 42−14=28 → (28, 14) 28−14=14 → (14, 14) 结果：gcd = 14 步骤数：4 步减法\n辗转相除法（除法）\n98÷56=1余 42 → (56, 42) 56÷42=1=1 余 14 → (42, 14) 42÷14=3 余 0 → 结束 结果：gcd = 14 步骤数：3 步除法\n这里看起来步骤差不多，但看下一个例子：\n例子二：求 gcd(100, 7)\n（这种情况：一个大数，一个很小的数）\n更相减损术（减法）\n结果：gcd = 1 步骤数：18 步减法！非常慢。\n辗转相除法（除法）\n结果：gcd = 1 步骤数：3 步除法！\n为什么除法是减法的“加速版”？\n减法：100−7要重复减很多次（14次！）才能让数字小于 7，得到余数 2。 除法：100÷7直接算出商 14 和余数 2，一步完成了减法要做的 14 次操作。 本质上：\n更相减损术：a→a−b（一次只减一个 b） 辗转相除法：a→a mod b（一次减掉 ⌊a/b⌋个 b） 所以除法是批量减法。\n再看一个例子：gcd(210, 45)\n总结\n更相减损术：容易理解，但数字相差大时效率低。 辗转相除法：效率高，因为用除法一步完成多次减法。 核心原理相同：gcd⁡(a,b)=gcd⁡(b,a−b)=gcd⁡(b,a mod b) 穷举法 从其中一个数字开始,依次递减,直到某个数除以两个数的余数都是0,此时这个数就是最大公约数。\n1 2 3 4 5 6 7 8 9 10 int gcd(int x,int y) { int t; for(t=x;;t--) { if(x%t==0 \u0026amp;\u0026amp; y%t==0) break; } return 0; } 求最小公倍数 公式 公式:lcm=x*y/gcd\n求两个数x和y的最小公倍数时, 最小公倍数=x*y/最大公约数。\n穷举法 1 2 3 4 5 6 7 8 9 10 11 12 13 int lcm(int x,int y) { if(x*y==0) return 0; int max = a \u0026gt; b ? a : b ; while(1) { if(max%a==0 \u0026amp;\u0026amp; max%b==0) break; max++; } return max; } ","date":"2025-11-15T17:25:13+08:00","permalink":"https://lidiudiudiu.github.io/p/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/","title":"最大公约数和最小公倍数"},{"content":"2536.子矩阵的元素+1 题目 给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。\n另给你一个二维整数数组 query 。针对每个查询 query[i] = [row1i, col1i, row2i, col2i] ，请你执行下述操作：\n找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 row1i \u0026lt;= x \u0026lt;= row2i 和 col1i \u0026lt;= y \u0026lt;= col2i 的 mat[x][y] 加 1 。 返回执行完所有操作后得到的矩阵 mat 。\n前缀和的主要思想是快速进行区间求和，本来可能需要从l加到r，使用前缀和之后只需要用prefix[r] - prefix[l-1]即可\n差分的主要思想是进行快速的区间更新，比如l到r的数字都加上1，只需要改为对差分数组两个端点进行操作\n频繁区间更新，少量查询：使用差分数组 频繁区间查询，少量更新：使用前缀和 都频繁：使用线段树或树状数组 二维前缀和\nsum [j+1] [j+1] 代表从左上角0，0 到 i，j的和 大一圈防止超过边界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 原始矩阵 const matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]; // 构建前缀和 (多一圈0，方便计算) const prefix = build2DPrefixSum(matrix); /* prefix 数组： [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] */ 构建\n1 2 3 4 5 6 7 8 9 10 11 12 function build2DPrefixSum(matrix) { const m = matrix.length, n = matrix[0].length; const prefix = new Array(m + 1).fill(0).map(() =\u0026gt; new Array(n + 1).fill(0)); for (let i = 1; i \u0026lt;= m; i++) { for (let j = 1; j \u0026lt;= n; j++) { prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]; } } return prefix; } 求和\n1 2 3 function query2DPrefixSum(prefix, x1, y1, x2, y2) { return prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]; } 思路 这题是矩阵的区间更新，所以用二维差分数组\n我是基于0-base,也就是0作为边界，这样需要特殊处理边界问题\n首先创建一个差分数组，还有一个前缀和数组作为最后的答案\n1 2 let copyArr = new Array(n).fill(0).map(arr =\u0026gt; Array(n).fill(0)); let mat = new Array(n).fill(0).map(arr =\u0026gt; Array(n).fill(0)); 遍历每次循环，取出对应的插入操作\n(r1,c1)++\n(r2+1,c1)\u0026ndash;\n(r1,c2+1)\u0026ndash;\n(r2+1,c2+1)++\n这里防止+1超出边界 所以在 r + 1 \u0026lt;= n-1时进行操作\n1 2 3 4 5 6 7 for (let query of queries) { const [r1,c1,r2,c2] = query; copyArr[r1][c1]++; if (r2 \u0026lt; n - 1) copyArr[r2+1][c1]--; if (c2 \u0026lt; n - 1)copyArr[r1][c2+1]--; if (r2 \u0026lt; n -1 \u0026amp;\u0026amp; c2 \u0026lt; n-1) copyArr[r2+1][c2+1]++; } 这里进行完插入操作之后，开始求前缀和\n因为这里的前缀和数组和差分数组一样大 所以需要特判之后再进行求前缀和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 mat[0][0] = copyArr[0][0]; for (let i = 1; i \u0026lt; n; i++) { mat[i][0] = mat[i-1][0] + copyArr[i][0]; } for (let j = 1; j \u0026lt; n; j++) { mat[0][j] = mat[0][j-1] + copyArr[0][j]; } for (let i = 1; i \u0026lt; n; i++) { for (let j = 1; j \u0026lt; n; j++) { mat[i][j] = mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1] + copyArr[i][j]; } } 完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function rangeAddQueries(n: number, queries: number[][]): number[][] { let copyArr = new Array(n).fill(0).map(arr =\u0026gt; Array(n).fill(0)); let mat = new Array(n).fill(0).map(arr =\u0026gt; Array(n).fill(0)); for (let query of queries) { const [r1,c1,r2,c2] = query; copyArr[r1][c1]++; if (r2 \u0026lt; n - 1) copyArr[r2+1][c1]--; if (c2 \u0026lt; n - 1)copyArr[r1][c2+1]--; if (r2 \u0026lt; n -1 \u0026amp;\u0026amp; c2 \u0026lt; n-1) copyArr[r2+1][c2+1]++; } mat[0][0] = copyArr[0][0]; for (let i = 1; i \u0026lt; n; i++) { mat[i][0] = mat[i-1][0] + copyArr[i][0]; } for (let j = 1; j \u0026lt; n; j++) { mat[0][j] = mat[0][j-1] + copyArr[0][j]; } for (let i = 1; i \u0026lt; n; i++) { for (let j = 1; j \u0026lt; n; j++) { mat[i][j] = mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1] + copyArr[i][j]; } } return mat; }; 总结 0-base与1-base 做完这道题我感觉到，前缀和差分推荐使用1-base 这样可以减少特判\n以0做边界，方便理解，但是需要的特殊边界判断多。\n一维前缀和 前缀和是用来快速计算数组区间和的，prefix[i]表示前i个或i+1个元素的和\n1-base\nprefix[0] = 0 prefix[i] 表示 nums[0] + nums[1] + ... + nums[i-1] 区间 [l, r] 的和 = prefix[r+1] - prefix[l] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class PrefixSum1Based { private prefix: number[]; constructor(nums: number[]) { const n = nums.length; this.prefix = new Array(n + 1).fill(0); // 构建前缀和数组，prefix[0] = 0 for (let i = 1; i \u0026lt;= n; i++) { this.prefix[i] = this.prefix[i - 1] + nums[i - 1]; //这里是nums[i-1]哦 } } // 查询区间 [l, r] 的和（0-indexed） queryRange(l: number, r: number): number { return this.prefix[r + 1] - this.prefix[l]; } // 查询前k个元素的和 queryPrefix(k: number): number { return this.prefix[k + 1]; } } 0-base\nprefix[0] = nums[0] prefix[i] 表示 nums[0] + nums[1] + ... + nums[i] 区间 [l, r] 的和 = prefix[r] - (l \u0026gt; 0 ? prefix[l-1] : 0) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class PrefixSum0Based { private prefix: number[]; constructor(nums: number[]) { const n = nums.length; this.prefix = new Array(n).fill(0); // 构建前缀和数组，prefix[0] = nums[0] if (n \u0026gt; 0) { this.prefix[0] = nums[0]; for (let i = 1; i \u0026lt; n; i++) { this.prefix[i] = this.prefix[i - 1] + nums[i]; } } } // 查询区间 [l, r] 的和（0-indexed） queryRange(l: number, r: number): number { if (l === 0) { return this.prefix[r]; } return this.prefix[r] - this.prefix[l - 1]; } // 查询前k个元素的和 queryPrefix(k: number): number { return this.prefix[k]; } } 二维前缀和 二维前缀和用于快速计算矩阵子矩阵的和。定义：\nprefix[i][j] 表示从 (0,0) 到 (i-1,j-1) 或 (i,j) 的子矩阵和 1-base\n定义：\nprefix[0][j] = 0, prefix[i][0] = 0 prefix[i][j] 表示 matrix[0][0] 到 matrix[i-1][j-1] 的和 子矩阵 [x1,y1] 到 [x2,y2] 的和 = prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1] 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class PrefixSum2D1Based { private prefix: number[][]; private rows: number; private cols: number; constructor(matrix: number[][]) { this.rows = matrix.length; this.cols = this.rows \u0026gt; 0 ? matrix[0].length : 0; // 初始化 (rows+1) x (cols+1) 的前缀和数组 this.prefix = Array.from({ length: this.rows + 1 }, () =\u0026gt; new Array(this.cols + 1).fill(0)); // 构建前缀和数组 for (let i = 1; i \u0026lt;= this.rows; i++) { for (let j = 1; j \u0026lt;= this.cols; j++) { this.prefix[i][j] = matrix[i - 1][j - 1] + this.prefix[i - 1][j] + this.prefix[i][j - 1] - this.prefix[i - 1][j - 1]; } } } // 查询子矩阵和 [x1, y1] 到 [x2, y2]（包含，0-indexed） querySubmatrix(x1: number, y1: number, x2: number, y2: number): number { return this.prefix[x2 + 1][y2 + 1] - this.prefix[x1][y2 + 1] - this.prefix[x2 + 1][y1] + this.prefix[x1][y1]; } // 获取整个矩阵的和 getTotalSum(): number { return this.prefix[this.rows][this.cols]; } // 打印前缀和数组（用于调试） printPrefix(): void { console.log(\u0026#34;1-based前缀和数组:\u0026#34;); for (let i = 0; i \u0026lt;= this.rows; i++) { console.log(this.prefix[i].map(x =\u0026gt; x.toString().padStart(2)).join(\u0026#39; \u0026#39;)); } } } 构建的时候 1 + 2 - 3 + 4\n查询的时候 4 -1 - 2 + 3\n0-base\n定义：\nprefix[0][0] = matrix[0][0] prefix[i][j] 表示 matrix[0][0] 到 matrix[i][j] 的和 需要处理边界条件 初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 构建前缀和数组 this.prefix[0][0] = matrix[0][0]; // 初始化第一行 for (let j = 1; j \u0026lt; this.cols; j++) { this.prefix[0][j] = this.prefix[0][j - 1] + matrix[0][j]; } // 初始化第一列 for (let i = 1; i \u0026lt; this.rows; i++) { this.prefix[i][0] = this.prefix[i - 1][0] + matrix[i][0]; } // 填充其余部分 for (let i = 1; i \u0026lt; this.rows; i++) { for (let j = 1; j \u0026lt; this.cols; j++) { this.prefix[i][j] = matrix[i][j] + this.prefix[i - 1][j] + this.prefix[i][j - 1] - this.prefix[i - 1][j - 1]; } } } 查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 查询子矩阵和 [x1, y1] 到 [x2, y2]（包含，0-indexed） querySubmatrix(x1: number, y1: number, x2: number, y2: number): number { let total = this.prefix[x2][y2]; if (x1 \u0026gt; 0) { total -= this.prefix[x1 - 1][y2]; } if (y1 \u0026gt; 0) { total -= this.prefix[x2][y1 - 1]; } if (x1 \u0026gt; 0 \u0026amp;\u0026amp; y1 \u0026gt; 0) { total += this.prefix[x1 - 1][y1 - 1]; } return total; } 一维差分数组 通常使用0-base即可\n差分数组是前缀和的逆运算，用于高效处理区间更新操作：\n原数组：arr 差分数组：diff[i] = arr[i] - arr[i-1] 通过差分数组可以高效进行区间加减操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class DifferenceArray { private diff: number[]; constructor(nums: number[]) { if (nums.length === 0) { this.diff = []; return; } // 构建差分数组 this.diff = new Array(nums.length); this.diff[0] = nums[0]; for (let i = 1; i \u0026lt; nums.length; i++) { this.diff[i] = nums[i] - nums[i - 1]; } } /** * 区间增加操作 * @param l 左边界（包含） * @param r 右边界（包含） * @param val 增加的值 */ increment(l: number, r: number, val: number): void { if (this.diff.length === 0) return; this.diff[l] += val; if (r + 1 \u0026lt; this.diff.length) { this.diff[r + 1] -= val; } } /** * 获取更新后的原数组 */ getResult(): number[] { if (this.diff.length === 0) return []; const result: number[] = new Array(this.diff.length); result[0] = this.diff[0]; for (let i = 1; i \u0026lt; this.diff.length; i++) { result[i] = result[i - 1] + this.diff[i]; } return result; } /** * 获取指定位置的值 */ getValueAt(index: number): number { if (index \u0026lt; 0 || index \u0026gt;= this.diff.length) { throw new Error(\u0026#34;Index out of bounds\u0026#34;); } let value = this.diff[0]; for (let i = 1; i \u0026lt;= index; i++) { value += this.diff[i]; } return value; } } // 使用示例 function demo() { // 原始数组 const nums = [1, 3, 2, 5, 8]; console.log(\u0026#34;原始数组:\u0026#34;, nums); // 创建差分数组 const diffArray = new DifferenceArray(nums); // 区间 [1, 3] 增加 2 diffArray.increment(1, 3, 2); console.log(\u0026#34;区间 [1,3] 增加 2 后的数组:\u0026#34;, diffArray.getResult()); // 区间 [0, 2] 增加 1 diffArray.increment(0, 2, 1); console.log(\u0026#34;区间 [0,2] 增加 1 后的数组:\u0026#34;, diffArray.getResult()); // 获取指定位置的值 console.log(\u0026#34;位置 2 的值:\u0026#34;, diffArray.getValueAt(2)); console.log(\u0026#34;位置 4 的值:\u0026#34;, diffArray.getValueAt(4)); } // 运行示例 demo(); 二维差分数组 二维差分数组是处理二维矩阵区间更新操作的高效数据结构，可以快速对子矩阵进行增减操作。\n基本定义\n二维差分数组是原二维数组的差分表示，用于高效处理子矩阵的区间更新。\n对于原矩阵 matrix[m][n]，其对应的二维差分数组 diff 满足：\ndiff[i][j] 记录了从 (0,0) 到 (i,j) 的累积变化 通过二维前缀和可以恢复原矩阵 二维差分利用容斥原理来高效更新子矩阵：\n1 2 3 4 5 要对子矩阵 (x1,y1) 到 (x2,y2) 增加 val，只需操作四个点： diff[x1][y1] += val diff[x1][y2+1] -= val diff[x2+1][y1] -= val diff[x2+1][y2+1] += val 因为差分数组需要多一行\n1 2 3 4 5 6 7 let diff: number[][] = Array.from({length: n+1}, () =\u0026gt; Array(n+1).fill(0)); for (let [row1, col1, row2, col2] of queries) { diff[row1][col1] += 1; diff[row2+1][col1] -= 1; diff[row1][col2+1] -= 1; diff[row2+1][col2+1] += 1; } ","date":"2025-11-14T16:07:14+08:00","permalink":"https://lidiudiudiu.github.io/p/2536.%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0-1/","title":"2536.子矩阵的元素+1"},{"content":"力扣题目未解决清单 计算子数组的 x-sum I 计算子数组的 x-sum II 完成所有送货任务的最少时间 最小化两个数组中的最大值 大于目标字符串的最小字典序回文排列 ","date":"2025-11-06T15:10:20+08:00","permalink":"https://lidiudiudiu.github.io/p/%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E6%9C%AA%E8%A7%A3%E5%86%B3%E6%B8%85%E5%8D%95/","title":"力扣题目未解决清单"},{"content":"475. 周赛 3731. 找出缺失的元素 给你一个整数数组 nums ，数组由若干 互不相同 的整数组成。\n数组 nums 原本包含了某个范围内的 所有整数 。但现在，其中可能 缺失 部分整数。\n该范围内的 最小 整数和 最大 整数仍然存在于 nums 中。\n返回一个 有序 列表，包含该范围内缺失的所有整数，并 按从小到大排序。如果没有缺失的整数，返回一个 空 列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function findMissingElements(nums: number[]): number[] { let min = 150,max = -1; let set = new Set\u0026lt;number\u0026gt;(); let result = new Array(); for (let i = 0; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; } if (nums[i] \u0026lt; min) { min = nums[i]; } set.add(nums[i]); } for (let i = min; i \u0026lt;= max; i++) { if (!set.has(i)) { result.push(i); } } return result; }; 把数组存到哈希表里，然后遍历最小值到最大值的区间，如果集合里没有这个数，那这个数就是答案之一。\n3733.完成所有送货任务的最少时间 给你两个大小为 2 的整数数组：d = [d1, d2] 和 r = [r1, r2]。\n两架送货无人机负责完成特定数量的送货任务。无人机 i 必须完成 di 次送货。\n每次送货花费 正好 一小时，并且在任何给定小时内 只有一架 无人机可以送货。\n此外，两架无人机都需要在特定时间间隔进行充电，在此期间它们不能送货。无人机 i 必须每 ri 小时充电一次（即在 ri 的倍数小时进行充电）。\n返回完成所有送货所需的 最小 总时间（以小时为单位）的整数。\n","date":"2025-11-06T13:32:14+08:00","permalink":"https://lidiudiudiu.github.io/p/475.%E5%91%A8%E8%B5%9B/","title":"475.周赛"},{"content":"3318. 计算子数组的 x-sum I ","date":"2025-11-06T13:19:27+08:00","permalink":"https://lidiudiudiu.github.io/p/3318.-%E8%AE%A1%E7%AE%97%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84-x-sum-i/","title":"3318. 计算子数组的 x-sum I"},{"content":"1578.把绳子变成彩色的最短时间 Alice 把 n 个气球排列在一根绳子上。给你一个下标从 0 开始的字符串 colors ，其中 colors[i] 是第 i 个气球的颜色。\nAlice 想要把绳子装扮成 五颜六色的 ，且她不希望两个连续的气球涂着相同的颜色，所以她喊来 Bob 帮忙。Bob 可以从绳子上移除一些气球使绳子变成 彩色 。给你一个 下标从 0 开始 的整数数组 neededTime ，其中 neededTime[i] 是 Bob 从绳子上移除第 i 个气球需要的时间（以秒为单位）。\n返回 Bob 使绳子变成 彩色 需要的 最少时间 。\n思路 核心思想：对于连续相同颜色的气球，我们保留移除代价最大的那个，移除其他所有。\n步骤：\n遍历气球数组 当遇到连续相同颜色时： 记录当前连续段的最大移除代价 累加较小的那个代价到结果中 更新最大代价为当前连续段的最大值 当颜色变化时，重置最大代价 这样可以在一次遍历中解决问题，时间复杂度 O(n)，空间复杂度 O(1)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function minCost(colors: string, neededTime: number[]): number { if (colors.length === 1) return 0; let totalTime = 0; let i = 0; while (i \u0026lt; colors.length - 1) { if (colors[i] === colors[i + 1]) { // 找到连续相同颜色的区间 let j = i; let maxTime = neededTime[i]; let sum = neededTime[i]; while (j \u0026lt; colors.length - 1 \u0026amp;\u0026amp; colors[j] === colors[j + 1]) { j++; sum += neededTime[j]; maxTime = Math.max(maxTime, neededTime[j]); } // 保留代价最大的，移除其他的 totalTime += (sum - maxTime); i = j; // 跳到连续区间的末尾 } i++; } return totalTime; }; 简洁写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function minCost(colors: string, neededTime: number[]): number { let totalTime = 0; let maxTime = neededTime[0]; for (let i = 1; i \u0026lt; colors.length; i++) { if (colors[i] === colors[i - 1]) { // 当前气球与前一个相同 totalTime += Math.min(neededTime[i], maxTime); maxTime = Math.max(maxTime, neededTime[i]); } else { // 颜色变化，重置 maxTime maxTime = neededTime[i]; } } return totalTime; }; 贪心\n根据题意可以知道，如果字符串 colors 中有若干相邻的重复颜色，则这些颜色中最多只能保留一个。因此，我们可以采取贪心的策略：在这一系列重复颜色中，我们保留删除成本最高的颜色，并删除其他颜色。这样得到的删除成本一定是最低的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function minCost(colors: string, neededTime: number[]): number { let i = 0, len = colors.length; let ret = 0; while (i \u0026lt; len) { const ch = colors[i]; let maxValue = 0; let sum = 0; while (i \u0026lt; len \u0026amp;\u0026amp; colors[i] === ch) { maxValue = Math.max(maxValue, neededTime[i]); sum += neededTime[i]; i++; } ret += sum - maxValue; } return ret; }; ","date":"2025-11-06T11:56:27+08:00","permalink":"https://lidiudiudiu.github.io/p/1578.%E6%8A%8A%E7%BB%B3%E5%AD%90%E5%8F%98%E6%88%90%E5%BD%A9%E8%89%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/","title":"1578.把绳子变成彩色的最短时间"},{"content":"数据结构 队列 在 TypeScript 中，队列的实现方式有多种。我来为你详细介绍几种常见的队列实现及其方法：\n使用数组模拟队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Queue\u0026lt;T\u0026gt; { private items: T[] = []; // 入队 - 添加元素到队列末尾 enqueue(element: T): void { this.items.push(element); } // 出队 - 移除并返回队列第一个元素 dequeue(): T | undefined { return this.items.shift(); } // 查看队列第一个元素 front(): T | undefined { return this.items[0]; } // 检查队列是否为空 isEmpty(): boolean { return this.items.length === 0; } // 获取队列大小 size(): number { return this.items.length; } // 清空队列 clear(): void { this.items = []; } // 打印队列 print(): void { console.log(this.items.toString()); } } // 使用示例 const queue = new Queue\u0026lt;number\u0026gt;(); queue.enqueue(1); queue.enqueue(2); queue.enqueue(3); console.log(queue.front()); // 1 console.log(queue.dequeue()); // 1 console.log(queue.size()); // 2 console.log(queue.isEmpty()); // false 使用链表实现队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class QueueNode\u0026lt;T\u0026gt; { constructor( public value: T, public next: QueueNode\u0026lt;T\u0026gt; | null = null ) {} } class LinkedListQueue\u0026lt;T\u0026gt; { private head: QueueNode\u0026lt;T\u0026gt; | null = null; private tail: QueueNode\u0026lt;T\u0026gt; | null = null; private count: number = 0; //进队列，构建目标节点 如果尾节点存在，接在尾节点后面，如果不存在把head指向新节点 //尾节点更新到新节点那里，节点数加一 enqueue(element: T): void { const newNode = new QueueNode(element); if (this.tail) { this.tail.next = newNode; } else { this.head = newNode; } this.tail = newNode; this.count++; } // 删除 先进先出 删除的是头节点 dequeue(): T | undefined { //如果头节点为空 没法删除 if (!this.head) return undefined; const value = this.head.value; this.head = this.head.next; //如果删除之后为空 if (!this.head) { this.tail = null; } this.count--; return value; } front(): T | undefined { return this.head?.value; } isEmpty(): boolean { return this.count === 0; } size(): number { return this.count; } clear(): void { this.head = null; this.tail = null; this.count = 0; } } 注意ts或者js中没有内置的队列，优先队列，栈，这些数据结构，是力扣平台内置的。\n","date":"2025-11-03T13:35:13+08:00","permalink":"https://lidiudiudiu.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构"},{"content":"2257.统计网格图中没有被保卫的格子数 题目 给你两个整数 m 和 n 表示一个下标从 0 开始的 m x n 网格图。同时给你两个二维整数数组 guards 和 walls ，其中 guards[i] = [rowi, coli] 且 walls[j] = [rowj, colj] ，分别表示第 i 个警卫和第 j 座墙所在的位置。\n一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 所有 格子，除非他们被一座墙或者另外一个警卫 挡住 了视线。如果一个格子能被 至少 一个警卫看到，那么我们说这个格子被 保卫 了。\n请你返回空格子中，有多少个格子是 没被保卫 的。\n思路 问题理解 有一个 m x n的格子，然后有三种类型的格子：\n警卫： 可以向四个放心看，直到被墙或者另一个警卫挡住 墙： 阻挡视线 空地： 初始未被保卫，被警卫看到，就变成被保卫 目标：统计最终没有被保卫的空地数量\n思考过程 模拟每个警卫的视线传播，标记所有能被看到的格子，最后统计没有被标记的格子数量。\n状态设计 代码使用数字常量来表示不同的格子状态：\n1 2 3 4 const GUARD = 1; // 警卫位置 const WALL = 2; // 墙的位置 const GUARDED = 4; // 被保卫的空地（能被至少一个警卫看到） const UNGUARDED = 0; // 未被保卫的空地（初始状态） 算法步骤 初始化阶段 1 const grid: number[][] = Array.from({ length: m }, () =\u0026gt; Array(n).fill(UNGUARDED)); 这里提一下Array.from的用法\nArray.from()的基本语法\n1 Array.from(arrayLike,mapFn,thisArg) arrayLike: 类数组对象或可迭代对象 mapFn(可选)：对每个元素执行的映射函数 thisArg(可选)：执行映射函数的this值 最常用的模式 {length:n}\n1 2 const arr = Array.from({ length: 5 }); console.log(arr); // [undefined, undefined, undefined, undefined, undefined] { length: 5 } 创建一个类数组对象，有 length 属性但没有实际元素 Array.from() 会读取 length 属性，知道要创建长度为5的数组 由于没有提供映射函数，每个位置都用 undefined 填充 结果：[undefined, undefined, undefined, undefined, undefined] 第二个例子 带映射\n1 2 const arr2 = Array.from({ length: 5 }, (_, i) =\u0026gt; i); console.log(arr2); // [0, 1, 2, 3, 4] 映射函数详解\n1 (_, i) =\u0026gt; i 第一个参数是当前元素的值，用_表示我们不关心这个值_\n第二个参数i是当前元素的索引\n返回值，返回当前元素本身\nArray.from()示例 创建数字序列\n1 2 3 4 5 // 创建 [0, 1, 2, 3, 4] const numbers = Array.from({ length: 5 }, (_, index) =\u0026gt; index); // 创建 [2, 4, 6, 8, 10] const evenNumbers = Array.from({ length: 5 }, (_, i) =\u0026gt; (i + 1) * 2); 创建矩阵\n1 2 3 4 5 // 3x3 单位矩阵 const matrix = Array.from({ length: 3 }, (_, i) =\u0026gt; Array.from({ length: 3 }, (_, j) =\u0026gt; i === j ? 1 : 0) ); // [[1,0,0], [0,1,0], [0,0,1]] 处理类对象数组\n1 2 3 4 5 6 // 从字符串创建数组 const chars = Array.from(\u0026#34;hello\u0026#34;); // [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] // 从Set创建数组 const set = new Set([1, 2, 3]); const arrFromSet = Array.from(set); // [1, 2, 3] 放置障碍物 1 2 3 4 5 6 7 8 9 // 标记墙 for (const [r, c] of walls) { grid[r][c] = WALL; } // 标记警卫 for (const [r, c] of guards) { grid[r][c] = GUARD; } 墙和警卫会阻挡视线，所以先固定它们的位置 视线传播（核心逻辑） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 上、下、左、右 for (const [r, c] of guards) { for (const [dr, dc] of directions) { let nr = r + dr; let nc = c + dc; while (nr \u0026gt;= 0 \u0026amp;\u0026amp; nr \u0026lt; m \u0026amp;\u0026amp; nc \u0026gt;= 0 \u0026amp;\u0026amp; nc \u0026lt; n) { if (grid[nr][nc] === WALL || grid[nr][nc] === GUARD) { break; // 遇到阻挡，停止该方向 } grid[nr][nc] = GUARDED; // 标记为被保卫 nr += dr; // 继续沿该方向前进 nc += dc; } } } 方向定义\n1 2 const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 分别表示：上、下、左、右 [-1, 0]: 向上移动 (行减1，列不变) [1, 0]: 向下移动 (行加1，列不变) [0, -1]: 向左移动 (行不变，列减1) [0, 1]: 向右移动 (行不变，列加1) 外层循环：遍历每个警卫\nfor (const [r, c] of guards) { // 对每个警卫处理四个方向 }\n[r,c]是当前警卫的坐标，对网格中的每个警卫都依次处理\n中层循环：处理四个方向\n1 2 3 for (const [dr, dc] of directions) { // 对每个方向进行射线扫描 } 每个警卫处理上下左右四个方向\n内层循环\n初始化射线起点\n1 2 let nr = r + dr; let nc = c + dc; 重要：从警卫的旁边一格开始，而不是从警卫本身开始！\n因为警卫所在位置已经被标记为 GUARD，不需要再标记 视线从警卫位置发出，但检查的是旁边的格子 射线循环传播\n1 2 3 while (nr \u0026gt;= 0 \u0026amp;\u0026amp; nr \u0026lt; m \u0026amp;\u0026amp; nc \u0026gt;= 0 \u0026amp;\u0026amp; nc \u0026lt; n) { // 在网格边界内才继续 } 阻挡检查\n1 2 3 if (grid[nr][nc] === WALL || grid[nr][nc] === GUARD) { break; // 遇到阻挡，停止该方向 } 标记被保卫\n1 grid[nr][nc] = GUARDED; // 标记为被保卫 移动到下一格\n1 2 nr += dr; nc += dc; 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 function countUnguarded(m: number, n: number, guards: number[][], walls: number[][]): number { // 用数字表示状态，便于检查 const GUARD = 1; const WALL = 2; const GUARDED = 4; // 被保卫的空地 const UNGUARDED = 0; // 未被保卫的空地（初始状态） // 初始化网格 const grid: number[][] = Array.from({ length: m }, () =\u0026gt; Array(n).fill(UNGUARDED)); // 标记墙 for (const [r, c] of walls) { grid[r][c] = WALL; } // 标记警卫 for (const [r, c] of guards) { grid[r][c] = GUARD; } // 四个方向：上、下、左、右 const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 对每个警卫进行视线传播 for (const [r, c] of guards) { for (const [dr, dc] of directions) { let nr = r + dr; let nc = c + dc; // 沿着方向一直走，直到遇到阻挡或边界 while (nr \u0026gt;= 0 \u0026amp;\u0026amp; nr \u0026lt; m \u0026amp;\u0026amp; nc \u0026gt;= 0 \u0026amp;\u0026amp; nc \u0026lt; n) { // 遇到墙或警卫就停止 if (grid[nr][nc] === WALL || grid[nr][nc] === GUARD) { break; } // 标记为被保卫 grid[nr][nc] = GUARDED; // 继续前进 nr += dr; nc += dc; } } } // 统计未被保卫的格子 let unguardedCount = 0; for (let i = 0; i \u0026lt; m; i++) { for (let j = 0; j \u0026lt; n; j++) { if (grid[i][j] === UNGUARDED) { unguardedCount++; } } } return unguardedCount; } 方法二：广度优先搜索 + 存储每个格子的状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 function countUnguarded(m: number, n: number, guards: number[][], walls: number[][]): number { let grid: number[][] = new Array(m).fill(0).map(() =\u0026gt; new Array(n).fill(0)); // 网格状态数组 let q = new Queue\u0026lt;[number, number, number]\u0026gt;; // 广度优先搜索队列 // 每个方向的单位向量 const dx = [1, 0, -1, 0]; const dy = [0, 1, 0, -1]; for (let guard of guards) { grid[guard[0]][guard[1]] = -1; for (let k = 0; k \u0026lt; 4; ++k) { // 将四个方向视线对应的状态均添加进搜索队列中 q.enqueue([guard[0], guard[1], k]); } } for (let wall of walls) { grid[wall[0]][wall[1]] = -2; } while (!q.isEmpty()) { let [x, y, k] = q.dequeue(); let nx = x + dx[k]; let ny = y + dy[k]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; m \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; n \u0026amp;\u0026amp; grid[nx][ny] \u0026gt;= 0) { // 沿着视线方向的下一个坐标合法，且不为警卫或墙 if ((grid[nx][ny] \u0026amp; (1 \u0026lt;\u0026lt; k)) === 0) { // 对应状态未遍历过 grid[nx][ny] |= (1 \u0026lt;\u0026lt; k); q.enqueue([nx, ny, k]); } } } let res = 0; // 未被保护格子数目 for (let i = 0; i \u0026lt; m; ++i) { for (let j = 0; j \u0026lt; n; ++j) { if (grid[i][j] === 0) { ++res; } } } return res; } 作者：力扣官方题解 链接：https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/solutions/1486086/tong-ji-wang-ge-tu-zhong-mei-you-bei-bao-ba6m/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 官方题解，没看懂\n灵茶山艾府的解法 暴力的想法是，依次检查每个空格子是否被保卫，即检查这个空格子上下左右方向上是否有警卫，且中间没有墙。但这样做的时间复杂度是 O(mn(m+n))。\n反过来，遍历警卫及其四个方向的视线，视线所及之处的空格子，标记为被保卫。用一个二维数组 guarded 记录被保卫的格子。\n最后遍历 guarded，统计没被保卫的格子个数。\n技巧：如果 (x,y) 处是警卫或者墙，那么标记 guarded[x] [y]=−1。当我们遍历到 guarded[x] [y]=−1 时，就不再继续遍历。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 左右上下 const DIRS = [[0, -1], [0, 1], [-1, 0], [1, 0]]; var countUnguarded = function(m, n, guards, walls) { const guarded = Array.from({ length: m }, () =\u0026gt; Array(n).fill(0)); // 标记警卫格子、墙格子 for (const [x, y] of guards) { guarded[x][y] = -1; } for (const [x, y] of walls) { guarded[x][y] = -1; } // 遍历警卫 for (const [x0, y0] of guards) { // 遍历视线方向（左右上下） for (const [dx, dy] of DIRS) { // 视线所及之处，被保卫 let x = x0 + dx, y = y0 + dy; while (0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; m \u0026amp;\u0026amp; 0 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt; n \u0026amp;\u0026amp; guarded[x][y] !== -1) { guarded[x][y] = 1; // 被保卫 x += dx; y += dy; } } } // 统计没被保卫的格子数 let ans = 0; for (const row of guarded) { for (const x of row) { if (x === 0) { // 没被保卫 ans++; } } } return ans; }; 类似题目 1222.可以攻击国王的皇后 在一个 下标从 0 开始 的 8 x 8 棋盘上，可能有多个黑皇后和一个白国王。\n给你一个二维整数数组 queens，其中 queens[i] = [xQueeni, yQueeni] 表示第 i 个黑皇后在棋盘上的位置。还给你一个长度为 2 的整数数组 king，其中 king = [xKing, yKing] 表示白国王的位置。\n返回 能够直接攻击国王的黑皇后的坐标。你可以以 任何顺序 返回答案。\n我的思路 定义要给grid二维数组，国王为-1，每个皇后为1，每个皇后遍历八个方向，每个方向上不断前进，如果遇到国王就跳出循环，如果遇到其它皇后或者墙就换一个方向，如果遍历了八个方向没有遇到国王，答案数量+1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function queensAttacktheKing(queens: number[][], king: number[]): number[][] { //初始化数组 let grid: number[][] = Array.from({length: 8}, () =\u0026gt; Array(8).fill(0)); const KING = -1; const QUEEN = 1; grid[king[0]][king[1]] = KING; let direction: number[][] = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]; for (let i = 0; i \u0026lt; queens.length; i++) { const [x,y] = queens[i]; grid[x][y] = QUEEN; } let result: number[][] = []; for (let i = 0; i \u0026lt; queens.length; i++) { const [qx,qy] = queens[i]; for (let j = 0; j \u0026lt; 8; j++) { const [dx,dy] = direction[j]; let x = qx + dx; let y = qy + dy; while (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; 8 \u0026amp;\u0026amp; y \u0026gt;=0 \u0026amp;\u0026amp; y \u0026lt; 8) { if (grid[x][y] == KING) { result.push([qx,qy]); break; } else if (grid[x][y] === QUEEN) { break; } else { x += dx; y += dy; } } } } return result; }; 三层循环但中间那层循环是8次常数相当于o1,所以最终时间复杂度为O(n2)\n更好解法 使用哈希Set\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function queensAttacktheKing(queens: number[][], king: number[]): number[][] { // 使用Set来快速判断位置是否有皇后 const queenSet = new Set(queens.map(queen =\u0026gt; `${queen[0]},${queen[1]}`)); const directions = [ [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1] ]; const result: number[][] = []; for (const [dx, dy] of directions) { let x = king[0] + dx; let y = king[1] + dy; while (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; 8 \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; 8) { if (queenSet.has(`${x},${y}`)) { result.push([x, y]); break; } x += dx; y += dy; } } return result; } Set引用\n在JavaScript/TypeScript中，Set使用严格相等（===）来判断元素是否存在：\n1 2 3 const set = new Set(); set.add([1, 2]); console.log(set.has([1, 2])); // false - 因为两个[1,2]是不同的引用 所以转成字符串\n字符串是值类型，相同的坐标会生成相同的字符串：\n1 2 3 const str1 = `${1},${2}`; // \u0026#34;1,2\u0026#34; const str2 = `${1},${2}`; // \u0026#34;1,2\u0026#34; console.log(str1 === str2); // true 方法二：从皇后出发 思路与算法\n我们枚举每个皇后，判断它是否在国王的八个方向上。如果在，说明皇后可以攻击到国王。\n同一个方向的皇后可能有多个，我们需要选择距离国王最近的那一个，因此可以使用一个哈希映射，它的键表示某一个方向，值是一个二元组，分别表示当前距离最近的皇后以及对应的距离。当我们枚举到一个新的皇后时，如果它在国王的八个方向上，就与哈希映射中对应的值比较一下大小关系即可。\n当枚举完所有皇后，我们就可以从哈希映射值的部分中得到答案。\nsgn是这样滴\n1 2 3 { -1, if x \u0026lt; 0 sgn(x) = { 0, if x = 0 { 1, if x \u0026gt; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var queensAttacktheKing = function(queens, king) { const sgn = function(x) { return x \u0026gt; 0 ? 1 : (x == 0 ? 0 : -1); } const candidates = new Map(); const kx = king[0], ky = king[1]; for (const queen of queens) { let qx = queen[0], qy = queen[1]; let x = qx - kx, y = qy - ky; if (x == 0 || y == 0 || Math.abs(x) == Math.abs(y)) { let dx = sgn(x), dy = sgn(y); const key = dx * 10 + dy; if (!candidates.has(key) || candidates.get(key)[2] \u0026gt; Math.abs(x) + Math.abs(y)) { candidates.set(key, [qx, qy, Math.abs(x) + Math.abs(y)]); } } } const ans = []; for (let value of candidates.values()) { ans.push([value[0], value[1]]); } return ans; }; 方法三 从国王出发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 var queensAttacktheKing = function(queens, king) { queen_pos = new Set(); for (const queen of queens) { let x = queen[0], y = queen[1]; queen_pos.add(x * 8 + y); } const ans = []; for (let dx = -1; dx \u0026lt;= 1; ++dx) { for (let dy = -1; dy \u0026lt;= 1; ++dy) { if (dx == 0 \u0026amp;\u0026amp; dy == 0) { continue; } let kx = king[0] + dx, ky = king[1] + dy; while (kx \u0026gt;= 0 \u0026amp;\u0026amp; kx \u0026lt; 8 \u0026amp;\u0026amp; ky \u0026gt;= 0 \u0026amp;\u0026amp; ky \u0026lt; 8) { let pos = kx * 8 + ky; if (queen_pos.has(pos)) { ans.push([kx, ky]); break; } kx += dx; ky += dy; } } } return ans; }; 作者：力扣官方题解 链接：https://leetcode.cn/problems/queens-that-can-attack-the-king/solutions/2436786/ke-yi-gong-ji-guo-wang-de-huang-hou-by-l-dbm7/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2025-11-02T10:09:20+08:00","permalink":"https://lidiudiudiu.github.io/p/2025.11.02-2257.%E7%BB%9F%E8%AE%A1%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A2%AB%E4%BF%9D%E5%8D%AB%E7%9A%84%E6%A0%BC%E5%AD%90%E6%95%B0/","title":"2025.11.02 2257.统计网格图中没有被保卫的格子数"},{"content":"数独教程1 数 ： 数字\n独： 独一无二\n格\t行\t列\t宫\n保证同一行，列，宫 每个数字只出现一次\n数独思维 以多优先 无论是行，列，宫 哪个单元的已知数最多，就从哪个单元考虑 确定数优先 格找数填 就是比如一行已经有了1 2 3那肯定是缺4 数找格填 横竖扫描 唯一解法 行唯一解\n列唯一解\n宫唯一解\n基本摒除法 宫摒除\n行列摒除法\n二余单元唯余解 ","date":"2025-11-02T10:07:42+08:00","permalink":"https://lidiudiudiu.github.io/p/%E6%95%B0%E7%8B%AC%E6%95%99%E7%A8%8B1/","title":"数独教程1"},{"content":"3217.从链表中移除在数组中存在的节点 题目 给你一个整数数组 nums 和一个链表的头节点 head。从链表中移除所有存在于 nums 中的节点后，返回修改后的链表的头节点。\n思路 我的思路 哈希，把数组存到哈希表里，两个指针 pre指向哑节点，cur指向当前节点。遍历链表 当哈希表中有cur.val的时候，把pre的next指向cur的next 最后返回dummy.next\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * class ListNode { * val: number * next: ListNode | null * constructor(val?: number, next?: ListNode | null) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } * } */ function modifiedList(nums: number[], head: ListNode | null): ListNode | null { let set = new Set(); for (let i = 0; i \u0026lt; nums.length; i++) { set.add(nums[i]); } let dummy = new ListNode(0,head); let pre = dummy,cur = head; while (cur) { if(set.has(cur.val)) { pre.next = cur.next; cur = cur.next; } else { pre = cur; cur = cur.next; } } return dummy.next; }; 遍历过程中一共两种情况 当前元素哈希表里有 删除当前元素 cur移动到下一个位置 没有的话先移动pre，再移动cur‘\n","date":"2025-11-02T10:05:39+08:00","permalink":"https://lidiudiudiu.github.io/p/2025.11.01-3217.%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%8A%82%E7%82%B9/","title":"2025.11.01 3217.从链表中移除在数组中存在的节点"},{"content":"3289.数字小镇中的捣蛋鬼 数字小镇 Digitville 中，存在一个数字列表 nums，其中包含从 0 到 n - 1 的整数。每个数字本应 只出现一次，然而，有 两个 顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。\n为了恢复 Digitville 的和平，作为小镇中的名侦探，请你找出这两个顽皮的数字。\n返回一个长度为 2 的数组，包含这两个数字（顺序任意）。\n示例 1：\n输入： nums = [0,1,1,0]\n输出： [0,1]\n解释：\n数字 0 和 1 分别在数组中出现了两次。\n示例 2：\n输入： nums = [0,3,2,1,3,2]\n输出： [2,3]\n解释:\n数字 2 和 3 分别在数组中出现了两次。\n示例 3：\n输入： nums = [7,1,5,4,3,4,6,0,9,5,8,2]\n输出： [4,5]\n解释:\n数字 4 和 5 分别在数组中出现了两次。\n提示：\n2 \u0026lt;= n \u0026lt;= 100 nums.length == n + 2 0 \u0026lt;= nums[i] \u0026lt; n 输入保证 nums 中 恰好 包含两个重复的元素。 哈希表 统计出现了两次的数字返回结果\n1 2 3 4 5 6 7 8 9 function getSneakyNumbers(nums: number[]): number[] { let map = new Map(); let result = new Array(); for (let i = 0; i \u0026lt; nums.length; i++) { map.set(nums[i],(map.get(nums[i]) ?? 0)+1); if (map.get(nums[i]) === 2) result.push(nums[i]); } return result; }; 位运算 我们将 nums 的所有数字和 0 到 n−1 的所有数字进行异或，那么计算结果为两个额外多出现一次的数字的异或值 y。那么两个数字最低不相同的位为 lowBit=y∧−y，利用 lowBit 将 nums 的所有数字和 0 到 n−1 的所有数字分成两部分，然后分别计算这两部分数字的异或值，即为结果。\n什么是异或，相同为假，不同为真。具有排他性的或。\n比如 1^1 = 0, 2^2=0\n那么对于0n-1 和 nums一起异或 因为nums里有0n-1 还有两个不一样得数字 所以最后得异或值y 就是两个多出来数字得异或值\n那么如何根据这个y得到两个重复数字 a和b呢 思路就是再把 a b分开 然后单独异或一下 a和b是单独的 就好啦\n得到最低不相同的位 lowbit = y ^ -y 因为负相当于补码 保留最低位1不变高位取反 这样就得到了最低位为1 为1说明a b这两位不同 这样就可以把a b分开\n把lowbit为1为一组 0~n中 nums中 这样异或就出来一个a lowbit为0的一组 这样异或出来一个b\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function getSneakyNumbers(nums: number[]): number[] { // 任何数字和0异或都等于它本身 let n = nums.length - 2; let y = 0; for (let i = 0; i \u0026lt; n; i++) { y = y ^ i; } for (let i = 0; i \u0026lt; nums.length;i++) { y = y ^ nums[i]; } //此时y的值是两个数字的异或 let lowBit = y \u0026amp; -y; let x1 = 0, x2 = 0; for (let i = 0; i \u0026lt; n; i++) { if (i \u0026amp; lowBit) { x1 = x1 ^ i; } else { x2 = x2 ^ i; } } for (let i = 0; i \u0026lt; nums.length; i++) { if (nums[i] \u0026amp; lowBit) { x1 = x1 ^ nums[i]; } else { x2 = x2 ^ nums[i]; } } return [x1,x2]; }; 我第一遍写犯下的两个错误分别是 取最低位应该用与 不是异或 第二个问题是第二个循环那个是nums[i]去与最低位。\n原地交换 1 2 3 4 5 6 7 8 9 10 function getSneakyNumbers(nums: number[]): number[] { for (let i = 0; i \u0026lt; nums.length; i++) { while (nums[i] !== i \u0026amp;\u0026amp; nums[nums[i]] !== nums[i]) { const temp = nums[nums[i]]; nums[nums[i]] = nums[i]; nums[i] = temp; } } return nums.slice(-2); } ","date":"2025-11-01T15:44:13+08:00","permalink":"https://lidiudiudiu.github.io/p/2025.10.31-3289.%E6%95%B0%E5%AD%97%E5%B0%8F%E9%95%87%E9%87%8C%E7%9A%84%E6%8D%A3%E8%9B%8B%E9%AC%BC/","title":"2025.10.31-3289.数字小镇里的捣蛋鬼"},{"content":"差分数组 什么是差分数组？ 差分数组是一个和原数组大小的数组，存储的是相邻数组的差值。\n具体来说：\n给定一个原数组 arr，其长度为 n。 我们可以构建一个差分数组 diff，其长度也为 n。 差分数组的元素定义如下： diff[0] = arr[0] （第一个元素没有前一个元素，所以它就是原数组的第一个值） diff[i] = arr[i] - arr[i-1] （对于 i 从 1 到 n-1） 一个简单的例子 假设我们有原数组： arr = [8, 2, 6, 3, 1]\n我们来构建它的差分数组 diff：\ndiff[0] = arr[0] = 8 diff[1] = arr[1] - arr[0] = 2 - 8 = -6 diff[2] = arr[2] - arr[1] = 6 - 2 = 4 diff[3] = arr[3] - arr[2] = 3 - 6 = -3 diff[4] = arr[4] - arr[3] = 1 - 3 = -2 所以，差分数组为： diff = [8, -6, 4, -3, -2]\n它有什么用？（核心优势） 差分数组最强大的功能是能极其高效地对原数组的某个区间进行批量增减操作。\n场景：如果你想给原数组 arr 中从索引 L 到索引 R 的每一个元素都加上一个值 val。\n传统做法：你需要一个循环，从 L 遍历到 R，逐个给元素加上 val。如果区间很大，这个操作的时间复杂度是 O(N)。\n使用差分数组的做法：你只需要修改差分数组中的两个值！\n给 diff[L] 加上 val。 给 diff[R+1] 减去 val。（如果 R+1 超出了数组范围，则忽略第二步） 这个操作的时间复杂度是 O(1)，与区间长度无关！\n为什么这样可行？（原理） 让我们通过上面的例子来理解。\n原数组： arr = [8, 2, 6, 3, 1] 差分数组： diff = [8, -6, 4, -3, -2]\n任务：我们想给 arr[1] 到 arr[3]（即 [2, 6, 3]）的每个元素都加上 5。\n传统做法： arr 变为 [8, 7, 11, 8, 1]\n差分数组做法：\nL = 1, R = 3, val = 5 第一步： diff[1] += 5 -\u0026gt; diff[1] 从 -6 变为 -1 第二步： diff[R+1] = diff[4] -= 5 -\u0026gt; diff[4] 从 -2 变为 -7 新的差分数组为： diff_new = [8, -1, 4, -3, -7] 现在，我们来验证这个新的差分数组是否对应新的原数组： 通过差分数组还原原数组（这个过程叫做“前缀和”运算）：\nnew_arr[0] = diff_new[0] = 8 new_arr[1] = new_arr[0] + diff_new[1] = 8 + (-1) = 7 new_arr[2] = new_arr[1] + diff_new[2] = 7 + 4 = 11 new_arr[3] = new_arr[2] + diff_new[3] = 11 + (-3) = 8 new_arr[4] = new_arr[3] + diff_new[4] = 8 + (-7) = 1 得到的新原数组是： [8, 7, 11, 8, 1]，这与传统方法得到的结果完全一致！\n原理分析：\ndiff[L] += val：这个操作意味着从 arr[L] 开始，之后的所有元素都在原始值的基础上增加了 val（因为还原时是累加差分数组）。 diff[R+1] -= val：这个操作是为了抵消掉从 arr[R+1] 开始之后所有元素不应该增加的 val，从而将增加操作精确地限制在 [L, R] 区间内。 具体代码 构建差分数组 差分数组第一个元素特殊处理一下 很好理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * 从原数组构建差分数组 * @param arr 原数组 * @returns 差分数组 */ function buildDiffArray(arr: number[]): number[] { const n = arr.length; const diff: number[] = new Array(n); // 第一个元素特殊处理 diff[0] = arr[0]; // 从第二个元素开始，计算差值 for (let i = 1; i \u0026lt; n; i++) { diff[i] = arr[i] - arr[i - 1]; } return diff; } // 示例 const originalArray = [1, 3, 2, 5, 8]; const diffArray = buildDiffArray(originalArray); console.log(\u0026#34;原数组:\u0026#34;, originalArray); // [1, 3, 2, 5, 8] console.log(\u0026#34;差分数组:\u0026#34;, diffArray); // [1, 2, -1, 3, 3] 更新差分数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * 对原数组的某个区间进行增减操作（通过差分数组） * @param diff 差分数组 * @param left 区间左边界（包含） * @param right 区间右边界（包含） * @param value 要增加的值（可为负数） */ function rangeUpdate(diff: number[], left: number, right: number, value: number): void { const n = diff.length; // 在左边界加上值 diff[left] += value; // 在右边界+1的位置减去值（如果存在） if (right + 1 \u0026lt; n) { diff[right + 1] -= value; } } // 使用示例 const arr = [1, 3, 2, 5, 8]; console.log(\u0026#34;原始数组:\u0026#34;, arr); // [1, 3, 2, 5, 8] const diff = buildDiffArray(arr); console.log(\u0026#34;差分数组:\u0026#34;, diff); // [1, 2, -1, 3, 3] // 给索引 1 到 3 的元素都加上 4 rangeUpdate(diff, 1, 3, 4); console.log(\u0026#34;更新后的差分数组:\u0026#34;, diff); // [1, 6, -1, 3, -1] const updatedArray = getPrefixSum(diff); console.log(\u0026#34;更新后的数组:\u0026#34;, updatedArray); // [1, 7, 6, 9, 8] 差分数组求和 差分数组第一个元素不变，然后累加元素和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 从差分数组求前缀和，还原原数组 * @param diff 差分数组 * @returns 原数组 */ function getPrefixSum(diff: number[]): number[] { const n = diff.length; const result: number[] = new Array(n); // 第一个元素保持不变 result[0] = diff[0]; // 累加前缀和 for (let i = 1; i \u0026lt; n; i++) { result[i] = result[i - 1] + diff[i]; } return result; } // 示例 const restoredArray = getPrefixSum(diffArray); console.log(\u0026#34;还原的数组:\u0026#34;, restoredArray); // [1, 3, 2, 5, 8] 力扣题目 1094 拼车 思路 构建一个位置差分数组 【0，to的最大值】，遍历trip，对于trip[i]，每次from到to-1加上numPassengers[i]个人,判断就是如果某个位置超过了最大容量capacity，就返回false。如果一直都能装下，就返回true。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function carPooling(trips: number[][], capacity: number): boolean { let n:number = 0; for (let i = 0; i \u0026lt; trips.length; i++) { const [,,to] = trips[i]; if (to \u0026gt; n) n = to; } let diff = new Array(n+1).fill(0); //差分数组初始全是0，直接更新相当于构建 for (let i = 0; i \u0026lt; trips.length; i++) { const [num,from,to] = trips[i]; diff[from] += num; diff[to] -= num; } // 前缀和构建原数组 看有没有超容量的站 let sum = 0; for (let i = 0; i \u0026lt;= n; i++) { sum += diff[i]; if (sum \u0026gt; capacity) return false; } return true; }; 多种题解 用哈希表，把哈希表的 key 取出来排序，就可以从小到大遍历这些位置了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var carPooling = function(trips, capacity) { const d = new Map(); for (const [num, from, to] of trips) { d.set(from, (d.get(from) ?? 0) + num); d.set(to, (d.get(to) ?? 0) - num); } let s = 0; for (const k of [...d.keys()].sort((a, b) =\u0026gt; a - b)) { s += d.get(k); if (s \u0026gt; capacity) { return false; } } return true; }; 作者：灵茶山艾府 链接：https://leetcode.cn/problems/car-pooling/solutions/2550264/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1526.形成目标数组的子数组最小增加次数 思路 1 2 3 4 5 6 7 8 9 10 11 12 var minNumberOperations = function(target) { let ans = target[0]; for (let i = 1; i \u0026lt; target.length; i++) { ans += Math.max(target[i] - target[i - 1], 0); } return ans; }; 作者：灵茶山艾府 链接：https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/solutions/3808716/yong-chai-fen-si-kao-jian-ji-xie-fa-pyth-0v7x/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 另一种思路\n","date":"2025-11-01T15:30:13+08:00","permalink":"https://lidiudiudiu.github.io/p/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","title":"差分数组"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://lidiudiudiu.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://lidiudiudiu.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://lidiudiudiu.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://lidiudiudiu.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://lidiudiudiu.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://lidiudiudiu.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://lidiudiudiu.github.io/p/emoji-support/","title":"Emoji Support"}]